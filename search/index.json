[{"content":"根据官方文档步骤 官方文档\n1. 首先需要创建vue项目 1 npm create vue@latest Tailwind-demo 2. 安装Tailwind CSS 通过 npm 安装 tailwindcss 和 @tailwindcss/vite。\n1 npm install tailwindcss @tailwindcss/vite 这里需要注意不要用3.x的安装方法去安装4.x版本。\n如果你用的是npm install -D tailwindcss postcss autoprefixer，说明安装的是3.x版本。\n之前我问AI如何安装结果给我整了一个3.x版本的安装方法。\n3. 配置Vite插件 将 @tailwindcss/vite 插件添加到你的 Vite 配置中(vite.config.ts文件)。\n1 2 import tailwindcss from \u0026#39;@tailwindcss/vite\u0026#39; tailwindcss(), 4. 导入 Tailwind CSS 新建 src\\styles\\index.css,引入 1 @import \u0026#34;tailwindcss\u0026#34;; 将该index.css导入main.ts入口文件 1 import \u0026#39;@/styles/index.css\u0026#39; 5.测试 1 \u0026lt;h1 class=\u0026#34;text-3xl font-bold text-center text-blue-300\u0026#34;\u0026gt;Hello world!\u0026lt;/h1\u0026gt; 可以发现Tailwind CSS 生效\n","date":"2025-08-19T15:46:51+08:00","permalink":"https://katomegumi.site/p/%E5%9C%A8vue3--vite-%E4%BD%BF%E7%94%A8tailwind-css-4.0/","title":"在vue3 + vite 使用Tailwind CSS 4.0"},{"content":"MCP是什么？ MCP官方文档 MCP 是一个开放协议，它为应用程序向 LLM 提供上下文的方式进行了标准化。你可以将 MCP 想象成 AI 应用程序的 USB-C 接口。就像 USB-C 为设备连接各种外设和配件提供了标准化的方式一样，MCP 为 AI 模型连接各种数据源和工具提供了标准化的接口。 MCP Servers 服务器每个专精一个服务。比如有的读取文件，有的访问浏览器。MCP server通常就是本地的nodejs或者python程序。其实就相当于是api，只不是是实现了MCP协议进行标准化罢了。因此你也可以自己写一个MCP服务器。 简单来说MCP就是AI大模型的标准化工具箱。大模型可以利用这些工具与外界互动。\n打一个比方，在平常我们使用AI需要手动截图或者复制问题到AI窗口进行对话。\n而MCP通过标准化的协议。可以自动帮助我们完成这些工作。MCP Server相当于AI与外部工具的中间层，代替人类访问并且操作外部工具。\n使用MCP 需要一个支持MCP协议的AI客户端。(Cursor,cline,cherry studio，WindSurf等) 对应的 MCP 服务器环境(node,python等) 以及你想使用的MCP服务器 这里我们就使用node环境和cline客户端。在vscode的扩展中下载cline。cline官方文档\n下载完成后。配置API。这里用的Open Router。然后再市场上选择你想下载的MCP服务\n这里使用github服务做一个例子。\n点击安装。他会自动打开一个AI聊天窗口。会指导你下载MCP服务。跟着来就行。\n这里需要获取你的github账号的token\n可以自行设定该token具有哪些权限。\n获取到token后自己填写到配置文件中或者将token输入给AI聊天框让AI给你配置。\n这里可以选用你自己的环境。比如docker、linux的sh。注意这里如果你是Windows可能需要修改 MCP服务器 的连接配置。\n实际上这个配置文件是最重要的。直接编写这个配置文件一样可以完成对应MCP服务器的配置。\ncommand是指定启动服务器的 “基础命令”\nargs 是 command 的参数列表，用于拼接完整的启动命令。\nMCP服务器显示绿色表明运行正常\n测试一下 在实际使用。我们不需要指定具体的MCP服务。AI会智能的从工具箱中寻找。自动进行使用。\n可以发现成功的运行了。\n总结 MCP的本质是 客户端调用了本地的命令行。然后调用本地运行的nodejs程序或者python(其实就是取决于你的MCP服务器用什么写的)然后程序执行了操作。将结果返回。\nMCP合集网站： https://smithery.ai/\n","date":"2025-08-09T14:25:15+08:00","permalink":"https://katomegumi.site/p/aimcp%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","title":"【AI】MCP入门学习"},{"content":"Nginx入门 这里我用的Ubuntu,首先下载nginx。\n1 apt install nginx nginx主要是通过 nginx.conf 文件进行配置的,这里我们来新写一个nginx.conf文件。由此来逐渐了解nginx的使用\n一些常用命令\n1 2 3 4 # 修改配置后 检查 Nginx 配置文件的语法是否正确 nginx -t # 校验通过后重载配置 nginx -s reload 1.Web服务器 Nginx 的配置是基于一套分层的块（block）结构，最核心的是 http, server, 和 location。\n1 2 3 4 5 6 7 8 9 10 11 12 13 events{} http{ #这里的server块定义的是虚拟服务器 server:{ listen 80; #监听80端口,因为一般浏览器默认用80端口进行请求 server_name localhost; #填写ip地址/自己的域名 return 200 \u0026#34;666\u0026#34;; #可以自己定义返回的内容 #注意 这时要删掉return这一行 不然会返回 return这一行 root /var/www/localhost; #指定网站根目录.这里会默认去找localhost文件中的index.html文件 #那么我们如何指定查找html文件 index app.html; #这样就会默认找app.html文件 } } 我们知道一个网站有多个文件。比如css文件。但是这时你引入css文件。打开浏览器会发现css文件类型居然是text/pain.这显然是不对的\nnginx中有这样一个文件mime.types文件 里面有文件类型对应的文件后缀。因此我们可以引入这个文件\n1 2 3 http{ include /etc/nginx/mime.types #这里注意写在http块里面，server块外面 相当于总配置 } 实际上nginx采用的是多文件配置。在nginx文件中有一个conf.d文件夹。里面有一个default.conf文件\n1 2 3 4 5 http{ #注意写在http里面 sever外面 相当于公共配置 include /etc/nginx/mime.types; include /ect/nginx/conf.d/*.conf;#这里的*是匹配所有后缀为conf文件 } 这样我们可以把我们之前写的nginx的server块配置移动到default.conf文件中。以后我们就改这个文件就行了\n2.location指令 使用location指令可以更好的指定路径\n1 2 3 4 5 6 7 8 9 10 11 12 server:{ listen 80; server_name localhost; #相当于匹配路径 location /{ root /var/www/localhost; } #(实际上是模糊匹配) 如果请求 localhost/apple 也一样会匹配成功 location /app{ root /var/www/localhost; # ** 映射到服务器的/var/www/localhost/app/ ** 所以我们这个文件夹一定要存在 } } 这里我们一定要注意location不仅匹配的uri。还会匹配对应路径的文件\n有四种匹配方式\nlocation = /path: 精确匹配。只有当 URI 完全是 /path 时才匹配。优先级最高。 location /path: 前缀匹配。匹配所有以 /path 开头的 URI。 location ~ /regex/: 正则表达式匹配 (区分大小写)。 loaction ~/video[4-9] 相当于匹配video4 video5\u0026hellip;. location ~* /regex/: 正则表达式匹配 (不区分大小写)。 匹配优先级: 精确匹配 (=) \u0026gt; 前缀匹配 \u0026gt; 正则表达式匹配 (~, ~*)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server{ #可以直接进行重写 用户访问 /temp 实际访问的服务器资源为/app/index.html rewrite /temp /app/index.html #但是这只能选择一个文件 如果要选择多个文件要用try_files location /{ #实际上就是一个一个尝试往下面找 如果有就返回 try_files $uri $uri/ =404; #这是一个很重要的配置 在配置vue .react有很重要的作用 } #以下是一个vue的例子 location /{ #这里如果都找不到。就去找目录的index.html文件。这样就能让vue路由接管。不然页面是访问不到的。因为Vue/Reacts是单页应用 (SPA) try_files $uri $uri/ /index.html } } 3.反向代理 1 2 3 4 5 6 7 server{ location /api { #这里就是将带有/api前缀的uri请求 转发给localhost:8123服务器 proxy_pass localhost:8123 } } 4.负载均匀 1 2 3 4 5 6 7 8 9 10 11 12 13 14 http{ #这里是设置一个上游服务器(注意写到http里面,server块的外面) upstream backend-servers { #设置权重 数字越大被分配的次数就会越多 server localhost:3000 weight 6; server localhsot:3001 weight 5; } sever{ #这里相当于把流量分配给上游的服务器 实际上也是代理 location /{ proxy_pass http://backend-servers } } } ","date":"2025-07-14T00:00:00Z","permalink":"https://katomegumi.site/p/nginx%E5%85%A5%E9%97%A8/","title":"Nginx入门"},{"content":"DDD领域驱动设计 要知道DDD架构 首先需要知道软件架构的演变之路\n一、三种软件架构 1.传统单体架构 所有的应用功能都集成在一个单一的应用程序中，所有模块和组件都在同一个进程内运行，请求直接操作数据库，不进行代码分层，易于开发和部署，尤其适合小型或简单的应用。\n随着业务增长和需求变更，单体架构变得难以扩展和维护。不同功能的模块耦合在一起，导致更新某个功能可能影响到整个系统。\n2.三层架构 应用被划分为不同的层（如业务接入层、业务逻辑层、数据访问层等），每一层负责特定的功能，层与层之间通过接口进行交互，促进了模块化和职责分离，便于管理和维护。\n但层与层之间的紧密耦合限制了灵活性，且随着系统的复杂度增加，可能导致性能下降和维护难度增加，并且它的可扩展性和弹性伸缩性差。\n3.微服务架构 将系统拆分为多个小而独立的服务，每个服务负责处理一组特定的功能，每个服务通常由独立的团队开发、部署和维护，服务之间通过轻量级协议（如 HTTP、自定义协议或消息队列）进行通信。\n服务之间独立，易于扩展和维护。每个微服务都可以独立部署、开发和扩展，且易于使用不同的技术栈。\n二、DDD 领域驱动设计概念 1.什么是DDD DDD（领域驱动设计，Domain-Driven Design） 是一种软件开发方法论和设计思想。DDD 通过领域驱动设计方法定义领域模型，从而确定业务和应用的边界，保证业务模型和代码模型的一致性。\n因为 DDD 主要应用在微服务架构场景，所以想要更好的理解 DDD 的概念，需要结合微服务架构来看：\nDDD 是一种设计思想，确定业务和应用的边界 微服务架构需要 将系统拆分为多个小而独立的服务 DDD 就是一个方法论，指导我们根据领域模型确定业务的边界，从而划分出应用的边界，最终落实成服务的边界、代码的边界。\n总结：因此。每个公司的DDD架构可能会有区别。DDD并没有统一的标准。但是设计思想是一致的。也就说DDD是一种设计思想 。是软件开发的方法论\n2. DDD 的目标 通过领域模型实现业务需求：开发者与领域专家共同理解业务需求，形成共享语言并构建模型。 提高系统的灵活性与可维护性：通过合理划分限界上下文，减少系统的耦合度，使得不同模块或子系统可以独立演化。 支持复杂业务逻辑的表达：通过深入的业务建模，使得复杂的业务逻辑能够清晰、准确地反映在代码中。 总结一下，就是让系统更贴合业务，让大型系统更利于独立建设和维护。\n3.DDD 建模总结 结合上面的名词解析，我们回顾一下 DDD 建模的流程。\n首先我们需要领域建模，此时会进行事件风暴，通过用例分析、场景分析等方式列出所有的业务行为与事件，找出产生这些行为的领域对象，包括实体与值对象。梳理这些领域对象之间的关系，从实体中找出聚合根，再根据聚合根的业务，找寻与其业务紧密关联其它实体与值对象，从而形成聚合。多个聚合之间根据业务相关性又可以划出限界上下文。\n可以通过 “开公司” 的比喻来帮助大家理解 DDD。领域就像公司的行业，决定了公司所从事的核心业务；限界上下文是公司内部的各个部门，每个部门有独立的职责和规则；实体是公司中的员工，具有唯一标识和生命周期；值对象是员工的地址或电话等属性，只有值的意义，没有独立的身份；聚合是部门，由多个实体和值对象组成，聚合根（如部门经理）是部门的入口，确保部门内部的一致性；领域服务则是跨部门的职能服务，比如 HR 或 IT 服务，为各部门提供支持和协作。\n4.DDD架构设计 1.充血模型和贫血模型 贫血模型和充血模型是两种面向对象设计模式，用于描述对象的职责划分和对象是否包含行为逻辑。\n简单来说贫血模型只具备状态(数据)而不具有行为(业务方法)\n充血模型既具备状态(数据)又具备行为(业务方法)\n以下为充血模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Order { private String orderId; private double totalAmount; private boolean isPaid; public Order(String orderId, double totalAmount) { this.orderId = orderId; this.totalAmount = totalAmount; this.isPaid = false; } public void pay() { if (this.isPaid) { throw new IllegalStateException(\u0026#34;Order is already paid\u0026#34;); } this.isPaid = true; } public void cancel() { if (this.isPaid) { throw new IllegalStateException(\u0026#34;Cannot cancel a paid order\u0026#34;); } // Perform cancellation logic } public boolean isPaid() { return isPaid; } public double getTotalAmount() { return totalAmount; } } 以下为贫血模型 在贫血模型中，Order 对象只包含数据（状态）而所有的业务逻辑（如 payOrder 和 cancelOrder）都被移到了外部的 OrderService 服务类中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Order { private String orderId; private double totalAmount; private boolean isPaid; public Order(String orderId, double totalAmount) { this.orderId = orderId; this.totalAmount = totalAmount; this.isPaid = false; } public String getOrderId() { return orderId; } public double getTotalAmount() { return totalAmount; } public boolean isPaid() { return isPaid; } public void setPaid(boolean paid) { isPaid = paid; } } public class OrderService { public void payOrder(Order order) { if (order.isPaid()) { throw new IllegalStateException(\u0026#34;Order is already paid\u0026#34;); } order.setPaid(true); } public void cancelOrder(Order order) { if (order.isPaid()) { throw new IllegalStateException(\u0026#34;Cannot cancel a paid order\u0026#34;); } // Perform cancellation logic } } 2.DDD 的分层架构 在领域驱动设计（DDD）中，分层架构模型是一种常见的设计模式，用于组织和管理系统的复杂性。通过将应用分为不同的层次，每一层都有清晰的责任和角色，从而促进了代码的高内聚、低耦合和可维护性。\nDDD 的分层架构主要有四层：用户接口层、应用层、领域层、基础设施层。每层负责不同的职责，协调工作以实现系统的整体功能。\n除基础设施层外，严格来说每层只能与 直接下层 产生依赖，即领域层只能被应用层调用，应用层只能被用户接口层调用。\n三、DDD重构 改造方法 领域划分 首先要从系统业务出发 看看能分出几个领域 如用户领域 。图片领域\n改造步骤 从源代码出发进行构建 而不是按照DDD四层架构一层一层去构建\n按照 model =\u0026gt; mapper =\u0026gt; service =\u0026gt; controller去重构\n而且一次只重构一个领域\n1.基础设施层 因为infrastructure 层是存放基础设施的代码，也就是通用的代码，所以需要要优先重构\n2.应用服务层 1.应用服务层需要调用领域服务层 因此在实现类当中应该要引入 2.应用服务层起到编排领域服务层的作用 3.原则上 上层接口只能调用下层接口。下层不能调用上层 因此如果原来的代码中有调用其他领域的方法需要放到应用服务层中 4.应用服务层也可以为其他的应用服务层提供服务 因此一些统一的服务 也要写到应用服务层 5.事务一般也写在应用服务层 总结：应用服务层起到编排领域服务层的作用。只要发现不调用其他应用服务的方法、并且不调用 “当前类中依赖其他应用服务” 的方法，就可以改为调用领域服务；否则该方法需要在应用服务中实现。\n3.领域服务层 领域服务层遵循的原则：\n需要调用数据库服务（repository）或基础设施层（infrastructure）来完成业务逻辑 可以根据需要，将和实体强相关的业务逻辑下沉到 实体类 中 4.用户接口层 主要保持精简不具备任何逻辑业务。只调用应用服务。\n可以具备转换类\n四、总结 其实 DDD 并不是多么“高大上”的知识，实际上有点类似于在传统分层架构的基础上多增加了一层 “应用服务层”，进一步的去细分职责。\n因此对于非大型项目来说，反而增加了额外的编码。一定要按需使用\n","date":"2025-03-20T00:00:00Z","permalink":"https://katomegumi.site/p/ddd%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/","title":"DDD领域驱动设计"},{"content":"redis在java基本的使用 ","date":"2025-02-28T00:00:00Z","permalink":"https://katomegumi.site/p/code/java/redis/","title":"redis在java基本的使用"},{"content":"我们的阅读理解出错了 学生这种生物， 每天都在寻找着“不明白的东西”的答案。 明天测验的答案，在班里的风评， 喜欢的人所喜欢的人。 这么说着的我：竹久优真，也正直面着一个问题。 是关于橡皮擦上写着的“我喜欢你”。 那正是我与憧憬的文学少女若宫雅两情相悦的确证，然而这份恋情却以玉碎结局结束了。 也就是说对象另有其人？\n在升入高中的春天，那份“误会”开始了。\n“你来得正好。我有点头疼的事情啊”\n被太阳少女宗像濑奈所收集的学园中的小小谜团们——\n那些，原来是将无数恋爱交缠在一起的事件\n","date":"2025-02-25T00:00:00Z","image":"https://katomegumi.site/p/acg/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E5%87%BA%E9%94%99%E4%BA%86/cropped_image_hu10251231148833521871.png","permalink":"https://katomegumi.site/p/acg/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%E5%87%BA%E9%94%99%E4%BA%86/","title":"关于我们的阅读理解出错了这件事"}]